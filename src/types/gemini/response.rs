use serde::{Deserialize, Serialize};
use serde_json::Value;

use super::request::*;

#[derive(Serialize, Deserialize, PartialEq, Eq, Debug)]
#[allow(non_camel_case_types)]
pub enum FinishReason {
    /// Default value. This value is unused.
    FINISH_REASON_UNSPECIFIED,
    /// Natural stop point of the model or provided stop sequence.
    STOP,
    /// The maximum number of tokens as specified in the request was reached.
    MAX_TOKENS,
    /// The response candidate content was flagged for safety reasons.
    SAFETY,
    /// The response candidate content was flagged for recitation reasons.
    RECITATION,
    /// The response candidate content was flagged for using an unsupported language.
    LANGUAGE,
    /// Unknown reason.
    OTHER,
    /// Token generation stopped because the content contains forbidden terms.
    BLOCKLIST,
    /// Token generation stopped for potentially containing prohibited content.
    PROHIBITED_CONTENT,
    /// Token generation stopped because the content potentially contains Sensitive Personally Identifiable Information (SPII).
    SPII,
    /// The function call generated by the model is invalid.
    MALFORMED_FUNCTION_CALL,
    /// Token generation stopped because generated images contain safety violations.
    IMAGE_SAFETY,
}

#[derive(Serialize, Deserialize)]
#[allow(non_snake_case)]
pub struct Candidate {
    pub content: Option<Chat>,
    pub finishReason: Option<FinishReason>,
}

#[derive(Serialize, Deserialize)]
#[allow(non_snake_case)]
pub struct GeminiResponse {
    pub candidates: Vec<Candidate>,
    pub usageMetadata: Value,
    pub modelVersion: String,
    pub promptFeedback: Option<Value>,
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    #[test]
    fn test_prohibited_content_response_parsing() {
        let prohibited_response = json!({
            "candidates": [
                {
                    "content": {},
                    "finishReason": "PROHIBITED_CONTENT"
                }
            ],
            "usageMetadata": {
                "promptTokenCount": 116295,
                "totalTokenCount": 116295,
                "trafficType": "ON_DEMAND"
            },
            "modelVersion": "gemini-2.5-pro"
        });

        // This should now parse successfully instead of failing
        let result = serde_json::from_value::<GeminiResponse>(prohibited_response);
        assert!(result.is_ok(), "Failed to parse PROHIBITED_CONTENT response: {:?}", result.err());

        let response = result.unwrap();
        assert_eq!(response.candidates.len(), 1);
        let candidate = &response.candidates[0];
        assert_eq!(candidate.finishReason, Some(FinishReason::PROHIBITED_CONTENT));
        
        // The fix allows parsing with empty content object, but it becomes Some with empty/default values
        if let Some(content) = &candidate.content {
            // Content exists but parts should be None due to the empty object
            assert!(content.parts.is_none(), "Parts should be None for empty content object");
        }
    }

    #[test]
    fn test_normal_response_parsing() {
        let normal_response = json!({
            "candidates": [
                {
                    "content": {
                        "parts": [{"text": "Hello world"}],
                        "role": "model"
                    },
                    "finishReason": "STOP"
                }
            ],
            "usageMetadata": {
                "promptTokenCount": 10,
                "totalTokenCount": 15
            },
            "modelVersion": "gemini-2.5-pro"
        });

        let result = serde_json::from_value::<GeminiResponse>(normal_response);
        assert!(result.is_ok(), "Failed to parse normal response: {:?}", result.err());

        let response = result.unwrap();
        let candidate = &response.candidates[0];
        assert_eq!(candidate.finishReason, Some(FinishReason::STOP));
        assert!(candidate.content.is_some(), "Content should be Some for normal response");
        
        if let Some(content) = &candidate.content {
            assert!(content.parts.is_some(), "Parts should be Some for normal response");
            if let Some(parts) = &content.parts {
                assert_eq!(parts.len(), 1);
            }
        }
    }
}
